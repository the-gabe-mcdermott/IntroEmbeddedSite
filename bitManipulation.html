<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, shrink-to-fit=no, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Introduction to Embedded Systems- Chapter 5: Bit Manipulation</title>

    <!-- Bootstrap Core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="css/simple-sidebar.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>
    <div id="wrapper">

         <!-- Sidebar -->
        <div id="sidebar-wrapper">
			<ul class="sidebar-nav">
				<li class="sidebar-brand">
					<a href="index.html">Intro Emb. Sys.</a>
                </li>
				<li>
					<a href="intro.html">Introduction</a>
				</li>
				<li>
					<a href="introToElectricity.html">Crash Course in Electricity</a>
				</li>
				<li>
					<a href="dataSheets.html">Data Sheets</a>
				</li>
				<li>
					<a href="bitManipulation.html">Bit Manipulation</a>
				</li>
				<li>
					<a href="glossaryAndIndex.html">Glossary/Index</a>
				</li>
			</ul>
        </div>
        <!-- /#sidebar-wrapper -->

        <!-- Page Content -->
        <div id="page-content-wrapper">
            <div class="container-fluid">
                <div class="row">
                    <div class="col-lg-12">
						<a href="#menu-toggle" class="btn btn-default" id="menu-toggle">Toggle Menu</a>
						
						<div class=chapterBody>
	

<h1> How to Manipulate Bits </h1>
	
<p>
I assume you are already familiar with binary and hexadecimal numbers. If not, learn about those before reading this chapter.
</p>

<h2> Why Does Setting or Clearing Bits Matter? </h2>

<p>
In embedded systems, individual bits can be very important.
A single bit in memory can be mapped to control the output of a single pin. A system timer may be enabled by setting a single bit in memory to a “1”. The problem is that most microcontrollers do not let us set the value of one bit in memory at a time. We must set a value to all the bits at the address. 
</p>

<p>
<strong>Addresses</strong> are how microcontrollers refer to specific memory locations. Similar to an apartment building with unit numbers to refer to specific apartments. 
</p>

<div class=default_diagram><img src="textbook-content/images/bitManipulation/AddressesAsApartments.png" 
	alt="Figure 1: A 5 story aprtment building with unit numbers writen on all ten apartments arragned in a neat grid."
	width="500" height="300"></div>
<p>
An addresses will usually refer to a memory location that contains multiple bits. For example a <strong>Byte Addressable</strong> microcontroller contains eight bits at every address.
</p>

<div class=default_diagram><img src="textbook-content/images/bitManipulation/zerosAtApartments.png" 
	alt="Figure 2: Similar to figure 1, except instead of apartment faces in a grid, 8 zeros are at each cell in the 2x5 grid."
	width="500" height="300">
</div>
<p> 
Another common kind of microcontroller is a <strong>Word Addressable</strong> microcontroller, where the manufacturer defines the number of bits in a word. Say, a Word Addressable microcontroller with 32-bit words would have 32 bits at every address.
</p>

<p>
When I start writing values into memory, I use an addresses to specify where I want the data written. However, I have no way of writing a value to a single bit at an address. It’s kind of like how an apartment number can let me find a specific apartment to deliver a package to, but not a specific room in that apartment. 
This make it impossible to write a single bit to say, turn on a system timer, without writing to the other bits at that address (which may control other things I don’t want to mess with.) The trick to get around this can be described in three steps.
</p>
<ol type=”1”>
	<li> Read the value at the memory location you are interested in. Store the value in some temporary variable  </li>
	<li> Perform a <strong>bitwise operation</strong> on the value to change only the bit or bits you are interested in changing, while leaving the rest at their previous value.</li>
	<li> Write the value back to the memory location. </li>
</ol>

<p>
You are still writing to all the bits at the address. But the bit you need changed gets assigned its new value, and the other bits at the address get written to the same value they had before. 
</p>


<h2> Bitwise Operations </h2>
<p>
Bitwise operations are just like ordinary mathematical operations (+, -, ect.). They take two numbers as an input (also known as two <strong> operands </strong>), and does something to them to create a result.  
</p>

<h2>C Boolean Logic Comparison Operators</h2>
<p>
There are three C operators for doing Boolean logic comparisons between two numbers, bit by bit. For example, the OR operator, written with the syntax “C = A | B;”, takes the first bit in variable A and the first bit in variable B, and performs a logical OR on the two bits. The result is stored in the first bit of C. Then, the second bit of A is compared against the second bit of B, and the result stored in the second bit of C. The same for the third bit, fourth, and so on.  
</p>

<table style="width:100%">
<tr>
	<th>Operator Name</th>
	<th>C Syntax</th>
</tr>
  
<tr>
    <td>OR</td>
    <td>A | B</td>
</tr>
  
<tr>
    <td>AND</td>
    <td>A & B</td>
</tr>

<tr>
	<td>EXCLUSIVE OR</td>
	<td>A ^ B</td>
</tr>
  
</tr>
</table>

<h3>Or Operator Example</h3>

<pre><code>
	A = 4’b0011;
	B = 4’b1010;

	C = A | B; 
	//C => 4’b1011
</code>
</pre>


<h3>And Operator Example</h3>

<pre>
<code>
	A = 4’b0011;
		
	B = 4’b1010;

	C = A & B;
	//C => 4’b0010
</code>
</pre>

<h3>Exclusive Or Example</h3>

<pre>
<code>
	A = 4’b0011;
	B = 4’b1010;
	
	C = A ^ B;
	//C => 4’b1001
</code>
</pre>

<h2>Shift Operators</h2>
<p>
	Shift operators shift the bits in the first operand by the number of positions specified by the second operand. There are left shift and right shift operators. You might be wondering what happens to the bits at the furthest right and left of the number. In a left shift, the left most bit is lost, and the right most bit gets assigned a zero. In a right shift, the right most bit is lost, and the left most bit gets assigned a zero. 
</p>

<table style="width:100%">
  
<tr>
    <th>Operator Name</th>
    <th>C Syntax</th>
</tr>

<tr>
	<td>LEFT SHIFT</td>
	<td>A << B</td>
</tr>

<tr>
	<td>RIGHT SHIFT</td>
	<td>A >> B</td>
</tr>
</table>

<h3>Left Shift Example</h3>

<pre>
<code>
	A = 4’b0110;
	B = 1;
	
	C = A << B;
	//C => 4’b1100;
	//Additional shifts cause bits to “roll off”
	C = C << B;
	//C => 4’b1000;
</code>
</pre>


<h3>Right Shift Example</h3>

<pre>
<code>
	A = 4’b0110;
	B = 1;

	C = A >> B;
	//C => 4’b0011;
	//Additional shifts cause bits to “roll off”
	C = C >> B;
	//C => 4’b0001;
</code>
</pre>


<h2>Negation Operator</h2>
<p>
Negation is performed as a unary operation. That is, it only has one operand. The bits in the operand are all flipped to their opposite.
</p>

<table style="width:100%">
<tr>
	<th>Operator Name</th>
	<th>Operator Synatx</th> 
</tr>

<tr>
    <td>ONES COMPLIMENT aka NOT</td>
    <td>~A</td>
</tr>
</table>

<h3>Ones Compliment Example</h3>

<pre>
<code>	
	A = 0’b0011;
	
	C = ~A;
	//C => 4’b1100;
</code>
</pre>


<h2> Bitwise Assignment Operators </h2>
<p>

Assignment Operators also exist, which assume that the variable on the left hand side is both the first operand, and also the variable to store the result in. The Bitwise Assignment Operators Are:
</p>
	
<table style="width:100%">
	
<tr>
	<th>Operator Name</th>
	<th>Operator Syntax</th> 
	
</tr>

<tr>
	<td>OR EQUALS</td>
	<td>|= A</td> 
</tr>
	
<tr>
	<td>AND EQUALS</td>
	<td>&= A</td> 
</tr>

<tr>
	<td>EXCLUSIVE OR EQUALS</td>
	<td>^= A</td>
</tr>
	
<tr>
	<td>LEFT SHIFT EQUALS</td>
	<td>>>= A</td>
</tr>

<tr>
	<td>RIGHT SHIFT EQUALS</td>
	<td><<= A</td>
</tr>
</table>
	

<h3>Or Equals Example</h3>

<pre>
<code>
	A = 4’b0011;
	B = 4’b1010;
	
	A |= B;  
	//A => 4’b1011;
</code>
</pre>

	
<h3>And Operator Example</h3>

<pre>
<code>
	A = 4’b0011;
	B = 4’b1010;

	A =& B;
	//C => 4’b0010
</code>
</pre>

<h3>Exclusive Or Example</h3>
 
<pre>
<code>
	A = 4’b0011;
	B = 4’b1010;

	A =^ B;
	//A => 4’b1001
</code>
</pre>

<h3>Left Shift Example</h3>
<code>
<pre>
	A = 4’b0110;
	B = 1;

	A =<< B;
	//A => 4’b1100;
	//Additional shifts cause bits to “roll off”
	A =<< B;
	//A => 4’b1000;
</code>
</pre>

	
<h3>Right Shift Example</h3>

<pre>
<code>
	A = 4’b0110;
	B = 1;

	A =>> B;
	//A => 4’b0011;
	//Additional shifts cause bits to “roll off”
	A =>> B;
	//A => 4’b0001;
	</code>
	</pre>
	
<h2> Putting Bitwise Operators to Work</h2>

<p>
To understand how to use bitwise operators to assign a value to only one bit at an address, I'll describe an example.
You are in charge of writing the software to control the display panel on the front of an wireless internet router.
There will be a bank of 8 LEDs on this display panel. The first, right most LED will indicate if the router is powered on.
The second LED will power on when a connection to the internet is active, and will power off if the connection is missing. 
The remaining 6 LEDS will show a kind of bar graph indicating the speed of the connection to the internet.
</p>

<p>
A member of your team has started a function to toggle the 2nd LED, indicating an active connection to the internet. 
</p>

<pre>
<code>
/*************************************************************************
* DisplayInternetStatus
* Inputs: 	uint8_t internet_connected_true-
*				Pass in a "1" if link is active.
* 			uint32_t * led_display_address
*				Pointer to address of front panel LED display.
***************************************************************/
void DisplayInternetStatus(uint8_t internet_connected_true, uint32_t * led_display_address)
{
	if (internet_connected_true == 1)
	{
		//There is a link to the internet!
		//TODO: Turn on the 2nd LED at address led_display_address
	
	}
	else
	{
		//internet gone.
		//TODO: Turn off the 2nd LED at address led_display_address.
	}
}
</pre>
</code>

<p>
Your job is to finish the function, turning on the LED when the link is active, and turning it off otherwise. 
You also need to make sure you leave all the other LEDs the way they were before the function was called, 
since they display other information.
</p>

<p>
	To accomplish this, you could write the following function.
</p>

<pre>
<code>
/******************************************************************
*	Bit2On
*	Inputs:	uint32_t * led_display_address
*			Pointer to address of front panel display.
*******************************************************************/
void Bit2On(uint32_t * led_display_address)
{
	//Note the mask is all zeros except for the 2nd bit.
	uint8_t const SECOND_BIT_MASK = 4’b0010;	
	
	//Temporary Variables.
	uint8_t led_write_data = 0;
	uint8_t led_read_data = 0;
	
	//Step 1) Read the data stored at the address. 
	//The "*" operator lets us read data from the 
	//address stored in "led_display_addres".
	
	led_read_data = *led_display_address;
	
	
	//Step 2) Use a bitwise OR operator along with the mask.
	led_write_data = led_read_data | SECOND_BIT_MASK;

	
	//In all the bit positions where the mask has a "0", the original value
	//is retained. (0 | 0 = 0, 1 | 0 = 1).
	//In all the bit positions where the mask has a "1", A "1" is assigned.
	//(0 | 1 = 1, 1 | 1 = 1)
	//This means  the second bit is set, and all other bits
	//Are whatever their original value was.
	
	
	
	//Step 3) Now write the entire temp variable to LED_BANK.
	//You are technically writing to the whole byte.
	//But since all the other bits are being re-written
	//To the same values they had before. Nobody is the wiser.
	*led_display_address = led_write_data;
	
}
</code>
</pre>


<p>
In order to turn that single LED off again, you could write this function.
</p>

<pre>
<code>
/******************************************************************
*	Bit2Off
*	Inputs:	uint32_t * led_display_address
*			Pointer to address of front panel display.
*******************************************************************/
void Bit2Off(uint32_t * led_display_address)
{
	//NOTE!!! our mask is inverted from the mask
	//used in the first example.
	int const SECOND_LED_MASK = 4’b1101;	
	uint8_t led_write_data = 0;
	uint8_t led_read_data = 0;
	
	//Step 1) Read the data stored at the address. 
	//The "*" operator lets us read data from the 
	//address stored in "led_display_address".
	
	led_read_data = *led_display_address;
	
	
	//Step 2) Use a bitwise AND operator along with the mask.
	led_write_data = led_read_data & SECOND_LED_MASK;

	
		
	//For bit positions where the mask has a "1", the original value
	//is retained. (0 & 1 = 0, 1 & 1 = 1).
	//In all the bit positions where the mask has a "0", A "0" is assigned.
	//(0 & 0 = 0, 1 & 0 = 0)
	//Only the second bit is cleared, the rest retain their original values.
	

	//Step 3) Write the entire temp variable to LED_BANK.
	*led_display_address = led_write_data;
	
}
</code>
</pre>

<p>
Then you can add your two functions to the code your team member started.
</p>

<pre>
<code>
/*************************************************************************
* DisplayInternetStatus
* Inputs: 	uint8_t internet_connected_true-
*				Pass in a "1" if link is active.
* 			uint32_t * led_display_address
*				Pointer to address of front panel LED display.
***************************************************************/
void DisplayInternetStatus(uint8_t internet_connected_true, uint32_t * led_display_address)
{
	if (internet_connected_true == 1)
	{
		//There is a link to the internet!
		Bit2On(led_display_address);
	}
	else
	{
		//internet gone.
		Bit2Off(led_display_address);
	}
}
</pre>
</code>

<p>
And that is how to toggle individual bits in memory when you can only address 8, or even 32 bits. 
</p>

<div class=well><samp>
“There are 10 kinds of people in the world: those who understand binary numerals, and those who don't.” - Ian Stewart
</samp></div>

</div>
<div class=license>
<p>
	&copy 2017
</p>
</div>

						
						
						
                    </div>
                </div>
            </div>
        </div>
        <!-- /#page-content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- jQuery -->
    <script src="js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="js/bootstrap.min.js"></script>

    <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>	
</body>

</html>
